.TH "LPM-INSTALL" "1" "July 2024" "LPM@0.1.0" ""
.SH "NAME"
\fBlpm-install\fR - Install a package
.SS "Synopsis"
.P
.RS 2
.nf
lpm install \[lB]package-spec...\[rB]

aliases: i, add
.fi
.RE
.SS "Description"
.P
This command installs a package and any packages that it depends on.
.SS "Flags"
.RS 0
.IP \(bu 4
\fB-D, --save-dev\fR: Package will appear in your \fBdevDependencies\fR.
.RE 0

.SS "Algorithm"
.P
Given a \fBpackage{dep}\fR structure: \fBA{B,C}, B{C}, C{D}\fR,
 the npm install algorithm produces:
.P
.RS 2
.nf
A
+-- B
+-- C
+-- D
.fi
.RE
.P
That is, the dependency from B to C is satisfied by the fact that A already
 caused C to be installed at a higher level. D is still installed at the top
 level because nothing conflicts with it.
.P
For \fBA{B,C}, B{C,D@1}, C{D@2}\fR, this algorithm produces:
.P
.RS 2
.nf
A
+-- B
+-- C
   `-- D@2
+-- D@1
.fi
.RE
.P
Because B's D@1 will be installed in the top-level, C now has to install
 D@2 privately for itself. This algorithm is deterministic, but different
 trees may be produced if two dependencies are requested for installation in
 a different order.

